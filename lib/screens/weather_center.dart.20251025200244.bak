import 'package:flutter/material.dart';
import '../ui/da_button.dart';
import '../services/wx_client.dart';

// Keep these imports in case you later wire the gate properly,
// but we won't depend on any static members from them right now.
import 'package:divergent_alliance/security/pin_gate.dart' as pin;
import 'package:divergent_alliance/screens/weather_center_gate.dart' as gate;

/// Wrapper that provides the exact members your file uses,
/// so existing code like `WeatherCenterGate.route` and
/// `WeatherCenterGate.authorized` compiles without touching
/// the rest of the file.
///
/// If your gate screen registers a named route elsewhere,
/// set the string below to match it. Otherwise this constant
/// simply satisfies the type checker.
class WeatherCenterGate {
  // Named route string used by your Navigator calls in this file.
  // Change the value to match your app's routes if needed.
  static const String route = '/weather-center-gate';

  // Authorization flag used by this screen's initState.
  // If your PIN gate exposes a real value, you can later
  // forward to it here (e.g., `return pin.GatewayPin.authorized;`).
  // For now we return true to unblock compilation.
  static bool get authorized => true;
}

// Brand theme for this screen (DA black + orange)
const Color brandOrange = Color(0xFFFF6A00);
const Color surfaceDark = Color(0xFF0B0B0C); // panel
const Color canvasBlack = Colors.black; // page background
// Brand theme for this screen (DA black + orange)

// ===================== Data model =====================
class SppRow {
  final String cluster;
  final String county;
  final String state;
  final double prob; // kept for backward compat, not shown
  final int population;
  final int suggestedCrews;
  final int predictedIncidents;
  final int predictedCustomersOut;
  final String staging;
  final String utilities;
  final String peakDate;
  final int threatLevel; // 0..3
  final double? maxGust;
  final double? maxSustained;

  static double? _asDouble(dynamic v) {
    if (v == null) return null;
    if (v is num) return v.toDouble();
    final s = v.toString().trim();
    if (s.isEmpty) return null;
    return double.tryParse(s);
  }

  static int _asInt(dynamic v) {
    if (v is int) return v;
    if (v is num) return v.toInt();
    return int.tryParse(v?.toString() ?? "") ?? 0;
  }

  SppRow.fromJson(Map<String, dynamic> j)
      : cluster = (j["Cluster"] ?? "").toString(),
        county = (j["County"] ?? "").toString(),
        state = (j["State"] ?? "").toString(),
        prob = _asDouble(j["Wind Outage probability %"] ?? j["prob"] ?? 0) ?? 0,
        population = _asInt(j["Population"]),
        suggestedCrews = _asInt(j["Suggested Crews"]),
        predictedIncidents = _asInt(j["Predicted Incidents"]),
        predictedCustomersOut =
        _asInt(j["Predicted Customers Out"] ?? j["customers_out"]),
        staging = (j["Staging Suggestions"] ?? "").toString(),
        utilities = (j["Primary + Secondary Utilities"] ?? "").toString(),
        peakDate = (j["Predicted Impact Date (peak)"] ?? "").toString(),
        threatLevel = _asInt(j["Threat Level"] ?? j["threat"] ?? 0),
        maxGust = _asDouble(j["Max Gust"] ?? j["max_gust"] ?? j["gust"]),
        maxSustained = _asDouble(
            j["Max Sustained"] ?? j["max_sustained"] ?? j["sustained"]);
}

// ===================== Modes =====================
enum ScopeMode { nationwide, region, state }
enum FilterMode { wind, threat }
enum WindMetric { gust, sustained }
enum SortMode { mph, threat, customers }

// ===================== Screen =====================
class WeatherCenter extends StatefulWidget {
  static const route = "/weather-center";
  const WeatherCenter({super.key});
  @override
  State<WeatherCenter> createState() => _WeatherCenterState();
}

class _WeatherCenterState extends State<WeatherCenter> {
  // ---- Regions ----
  final Map<String, List<String>> regionStates = const {
    "Gulf": ["Texas", "Louisiana", "Mississippi", "Alabama", "Florida"],
    "Southeast": [
      "Florida",
      "Georgia",
      "South Carolina",
      "North Carolina",
      "Tennessee",
      "Alabama",
      "Mississippi"
    ],
    "East Coast": [
      "Florida",
      "Georgia",
      "South Carolina",
      "North Carolina",
      "Virginia",
      "Maryland",
      "Delaware",
      "New Jersey",
      "New York",
      "Connecticut",
      "Rhode Island",
      "Massachusetts"
    ],
    "Midwest": [
      "Illinois",
      "Indiana",
      "Ohio",
      "Michigan",
      "Wisconsin",
      "Minnesota",
      "Missouri",
      "Iowa"
    ],
    "West": [
      "California",
      "Oregon",
      "Washington",
      "Nevada",
      "Arizona",
      "Utah",
      "Colorado",
      "New Mexico"
    ],
  };

  // ---- Scope state ----
  ScopeMode _scope = ScopeMode.nationwide;
  String region = "Nationwide";
  String? stateSel;
  int daysOut = 0;

  // ---- Filter state ----
  FilterMode _mode = FilterMode.wind;
  WindMetric _windMetric = WindMetric.gust;
  double _mphThreshold = 40; // default mph threshold
  int? _threatOverride;

  // ---- Sort state ----
  SortMode _sort = SortMode.mph;

  // ---- Data and derived ----
  List<SppRow> _rows = [];
  bool _loading = false;
  bool _hasRun = false;
  String? _runNote;
  int _derivedThreat = 0;
  String _derivedStaging = "";
  double? _maxGust;
  double? _maxSustained;

  @override
  void initState() {
    super.initState();
    if (WeatherCenterGate.authorized != true) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.pushReplacementNamed(context, WeatherCenterGate.route);
      });
    }
  }

  // ---- Helpers ----
  List<String> currentStatesForRegion(String r) =>
      regionStates[r] ?? const <String>[];

  String threatLabel(int lvl) => switch (lvl) {
    3 => "Level 3",
    2 => "Level 2",
    1 => "Level 1",
    _ => "Level 0"
  };
  Color threatColor(int lvl) => switch (lvl) {
    3 => const Color(0xFFB00020),
    2 => brandOrange,
    1 => const Color(0xFFFFC107),
    _ => const Color(0xFF64B5F6),
  };

  String _scopeLabel() => (_scope == ScopeMode.state && stateSel != null)
      ? "by State"
      : (_scope == ScopeMode.region && region != "Nationwide")
      ? "by Region"
      : "by Nationwide";

  String _fixText(String s) {
    // scrub any mojibake we have seen in CSVs
    return s
        .replaceAll(
        "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã‚Â¡ÃƒÆ’Ã¢â‚¬Å¡Ãƒâ€šÃ‚Â¬",
        "ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬")
        .replaceAll("ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€šÃ‚Â¢", "ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¢")
        .replaceAll(
        "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â‚¬Å¡Ã‚Â¬Ãƒâ€¦Ã¢â‚¬Å“",
        "ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬Å“")
        .replaceAll(
        "ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬ÃƒÆ’Ã‚Â¢Ãƒâ€šÃ‚Â¢",
        "ÃƒÂ¢Ã¢â€šÂ¬Ã‚Â¢")
        .replaceAll("ÃƒÆ’Ã†â€™Ãƒâ€šÃ‚Â¢ÃƒÆ’Ã‚Â¢ÃƒÂ¢Ã¢â€šÂ¬Ã…Â¡Ãƒâ€šÃ‚Â¬",
        "ÃƒÂ¢Ã¢â€šÂ¬Ã¢â‚¬");
  }

  // ---- Sorting and filtering ----
  double _mphOf(SppRow r) =>
      _windMetric == WindMetric.gust ? (r.maxGust ?? 0) : (r.maxSustained ?? 0);

  List<SppRow> _filteredRows() {
    final list = [..._rows];
    if (_mode == FilterMode.wind) {
      list.removeWhere((r) => _mphOf(r) < _mphThreshold);
    }
    if (_scope == ScopeMode.state && stateSel != null) {
      list.retainWhere((r) => r.state == stateSel);
    } else if (_scope == ScopeMode.region && region != "Nationwide") {
      final states = currentStatesForRegion(region);
      list.retainWhere((r) => states.contains(r.state));
    }
    return list;
  }

  List<SppRow> _sortedRows() {
    final list = _filteredRows();
    switch (_sort) {
      case SortMode.mph:
        list.sort((a, b) => _mphOf(b).compareTo(_mphOf(a)));
        break;
      case SortMode.threat:
        list.sort((a, b) => b.threatLevel.compareTo(a.threatLevel));
        break;
      case SortMode.customers:
        list.sort((a, b) =>
            b.predictedCustomersOut.compareTo(a.predictedCustomersOut));
        break;
    }
    return list;
  }

  Future<void> _run() async {
    if (WeatherCenterGate.authorized != true) {
      Navigator.pushReplacementNamed(context, WeatherCenterGate.route);
      return;
    }
    setState(() {
      _loading = true;
      _hasRun = true;
      _runNote = null;
    });

    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
      content: Text("Running forecast…"),
      duration: Duration(milliseconds: 900),
    ));

    try {
      final List<Map<String, dynamic>> data =
      await WxClient.nationalCsv().timeout(
        const Duration(seconds: 12),
        onTimeout: () =>
        throw "Backend timeout 12s. Check connectivity or server load.",
      );

      final rows = data.map((e) => SppRow.fromJson(e)).toList();

      final lvlFromBackend = rows.isEmpty
          ? 0
          : rows.map((e) => e.threatLevel).reduce((a, b) => a > b ? a : b);

      final gusts = rows.map((r) => r.maxGust).whereType<double>().toList();
      final susts =
      rows.map((r) => r.maxSustained).whereType<double>().toList();
      final maxGust =
      gusts.isEmpty ? null : gusts.reduce((a, b) => a > b ? a : b);
      final maxSustained =
      susts.isEmpty ? null : susts.reduce((a, b) => a > b ? a : b);

      setState(() {
        _rows = rows;
        _derivedThreat = lvlFromBackend;
        _derivedStaging = rows.isNotEmpty
            ? rows.first.staging
            : "Nationwide posture • maintain rapid deploy crews at key logistics hubs.";
        _maxGust = maxGust;
        _maxSustained = maxSustained;
        _runNote = rows.isEmpty
            ? "No forecast rows returned. Adjust scope or days, then try again."
            : null;
      });

      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
        content: Text("Forecast updated"),
        duration: Duration(milliseconds: 900),
      ));
    } catch (e) {
      if (!mounted) return;
      setState(() => _runNote = "Error: $e");
    } finally {
      if (mounted) setState(() => _loading = false);
    }
  }

  // ===================== BUILD =====================
  @override
  Widget build(BuildContext context) {
    final effectiveThreat = (_mode == FilterMode.threat)
        ? (_threatOverride ?? _derivedThreat)
        : _derivedThreat;
    final badgeColor = threatColor(effectiveThreat);
    final sorted = _sortedRows();

    return Theme(
      data: Theme.of(context).copyWith(
        colorScheme: const ColorScheme(
          brightness: Brightness.dark,
          primary: brandOrange,
          onPrimary: Colors.black,
          secondary: brandOrange,
          onSecondary: Colors.black,
          surface: surfaceDark,
          onSurface: Colors.white,
          background: canvasBlack,
          onBackground: Colors.white,
          error: Color(0xFFCF6679),
          onError: Colors.black,
        ),
        scaffoldBackgroundColor: canvasBlack,
        appBarTheme: const AppBarTheme(
          backgroundColor: canvasBlack,
          foregroundColor: Colors.white,
          elevation: 0,
        ),
        cardColor: surfaceDark,
        inputDecorationTheme: const InputDecorationTheme(
          filled: true,
          fillColor: surfaceDark,
          border: OutlineInputBorder(
            borderSide: BorderSide(color: Color(0x22FFFFFF)),
            borderRadius: BorderRadius.all(Radius.circular(12)),
          ),
          enabledBorder: OutlineInputBorder(
            borderSide: BorderSide(color: Color(0x22FFFFFF)),
            borderRadius: BorderRadius.all(Radius.circular(12)),
          ),
          focusedBorder: OutlineInputBorder(
            borderSide: BorderSide(color: brandOrange, width: 1.2),
            borderRadius: BorderRadius.all(Radius.circular(12)),
          ),
          labelStyle: TextStyle(color: Colors.white70),
        ),
        toggleButtonsTheme: const ToggleButtonsThemeData(
          selectedColor: Colors.white,
          color: Colors.white70,
          fillColor: Color(0x22FF6A00),
          borderColor: Color(0x44FFFFFF),
          selectedBorderColor: brandOrange,
          borderRadius: BorderRadius.all(Radius.circular(12)),
        ),
        sliderTheme: const SliderThemeData(
          activeTrackColor: brandOrange,
          thumbColor: brandOrange,
          inactiveTrackColor: Color(0x33FFFFFF),
          overlayColor: Color(0x22FF6A00),
        ),
        snackBarTheme: const SnackBarThemeData(
          backgroundColor: surfaceDark,
          contentTextStyle: TextStyle(color: Colors.white),
          behavior: SnackBarBehavior.floating,
        ),
      ),
      child: Scaffold(
        appBar: AppBar(
          title: const Text("Weather Center"),
          bottom: _loading
              ? const PreferredSize(
            preferredSize: Size.fromHeight(3),
            child:
            LinearProgressIndicator(minHeight: 3, color: brandOrange),
          )
              : null,
          actions: [
            Container(
              margin: const EdgeInsets.symmetric(vertical: 10, horizontal: 12),
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
              decoration: BoxDecoration(
                color: badgeColor.withValues(alpha: .18),
                border: Border.all(color: badgeColor, width: 1),
                borderRadius: BorderRadius.circular(20),
              ),
              child: Row(children: [
                const Icon(Icons.bolt_rounded, size: 16),
                const SizedBox(width: 6),
                Text(threatLabel(effectiveThreat),
                    style: const TextStyle(fontWeight: FontWeight.w700)),
              ]),
            ),
          ],
        ),
        body: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            children: [
              // ===== Scope =====
              _sectionLabel(context, "Scope"),
              const SizedBox(height: 8),
              ToggleButtons(
                isSelected: [
                  _scope == ScopeMode.nationwide,
                  _scope == ScopeMode.region,
                  _scope == ScopeMode.state,
                ],
                onPressed: (i) => setState(() {
                  _scope = ScopeMode.values[i];
                  if (_scope != ScopeMode.region) region = "Nationwide";
                  if (_scope != ScopeMode.state) stateSel = null;
                }),
                borderRadius: BorderRadius.circular(12),
                children: const [
                  _TBtn("Nationwide"),
                  _TBtn("Region"),
                  _TBtn("State")
                ],
              ),
              if (_scope == ScopeMode.region) ...[
                const SizedBox(height: 8),
                DropdownButtonFormField<String>(
                  value: region == "Nationwide" ? null : region,
                  decoration: const InputDecoration(labelText: "Region"),
                  items: regionStates.keys
                      .map((r) => DropdownMenuItem(value: r, child: Text(r)))
                      .toList(),
                  onChanged: (v) => setState(() {
                    region = v ?? "Nationwide";
                    stateSel = null;
                  }),
                ),
              ],
              if (_scope == ScopeMode.state) ...[
                const SizedBox(height: 8),
                DropdownButtonFormField<String>(
                  value: stateSel,
                  decoration: const InputDecoration(labelText: "State"),
                  items: regionStates.values
                      .expand((lst) => lst)
                      .toSet()
                      .toList()
                      .map((s) => DropdownMenuItem(value: s, child: Text(s)))
                      .toList(),
                  onChanged: (v) => setState(() => stateSel = v),
                ),
              ],

              const SizedBox(height: 12),

              // ===== Forecast window =====
              _sectionLabel(context, "Forecast window"),
              Row(children: [
                const Expanded(child: Text("Days out")),
                Text("${daysOut} d",
                    style: const TextStyle(fontWeight: FontWeight.w600)),
              ]),
              Slider(
                min: 0,
                max: 10,
                divisions: 10,
                value: daysOut.toDouble(),
                label: daysOut.toString(),
                onChanged: (v) => setState(() => daysOut = v.round()),
              ),

              const SizedBox(height: 12),

              // ===== Filter =====
              _sectionLabel(context, "Filter"),
              ToggleButtons(
                isSelected: [
                  _mode == FilterMode.wind,
                  _mode == FilterMode.threat
                ],
                onPressed: (i) => setState(() => _mode = FilterMode.values[i]),
                borderRadius: BorderRadius.circular(12),
                children: const [_TBtn("Wind"), _TBtn("Threat")],
              ),

              if (_mode == FilterMode.wind) ...[
                const SizedBox(height: 8),
                DropdownButtonFormField<WindMetric>(
                  value: _windMetric,
                  decoration: const InputDecoration(labelText: "Wind metric"),
                  items: const [
                    DropdownMenuItem(
                        value: WindMetric.gust, child: Text("Gust mph")),
                    DropdownMenuItem(
                        value: WindMetric.sustained,
                        child: Text("Sustained mph")),
                  ],
                  onChanged: (v) =>
                      setState(() => _windMetric = v ?? _windMetric),
                ),
                const SizedBox(height: 8),
                Row(children: [
                  const Expanded(child: Text("Threshold")),
                  Text("${_mphThreshold.toStringAsFixed(0)} mph",
                      style: const TextStyle(fontWeight: FontWeight.w600)),
                ]),
                Slider(
                  min: 0,
                  max: 120,
                  divisions: 120,
                  value: _mphThreshold,
                  label: _mphThreshold.toStringAsFixed(0),
                  onChanged: (v) => setState(() => _mphThreshold = v),
                ),
              ],

              if (_mode == FilterMode.threat) ...[
                const SizedBox(height: 8),
                DropdownButtonFormField<String>(
                  value: _threatOverride == null
                      ? 'Auto'
                      : 'Level ${_threatOverride}',
                  decoration: const InputDecoration(labelText: 'Threat level'),
                  items: const [
                    DropdownMenuItem(
                        value: 'Auto', child: Text('Auto from backend')),
                    DropdownMenuItem(value: 'Level 0', child: Text('Level 0')),
                    DropdownMenuItem(value: 'Level 1', child: Text('Level 1')),
                    DropdownMenuItem(value: 'Level 2', child: Text('Level 2')),
                    DropdownMenuItem(value: 'Level 3', child: Text('Level 3')),
                  ],
                  onChanged: (v) => setState(() {
                    if (v == null || v == 'Auto') {
                      _threatOverride = null;
                    } else {
                      _threatOverride = int.parse(v.split(' ').last);
                    }
                  }),
                ),
              ],

              const SizedBox(height: 12),

              // ===== Operational summary =====
              _sectionLabel(
                context,
                _mode == FilterMode.wind
                    ? "Operational summary, Wind"
                    : "Operational summary, Threat",
              ),
              const SizedBox(height: 6),
              _cardsRow(
                context,
                threat: threatLabel(effectiveThreat),
                threatColor: badgeColor,
                staging: _fixText(_derivedStaging),
                scopeLabel: stateSel ?? region,
                maxGust: _maxGust?.toStringAsFixed(0) ?? "—",
                maxSustained: _maxSustained?.toStringAsFixed(0) ?? "—",
              ),

              if (_hasRun && !_loading && (_rows.isEmpty || _runNote != null))
                Padding(
                  padding: const EdgeInsets.only(top: 12),
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(14),
                    decoration: BoxDecoration(
                      color: Colors.white.withValues(alpha: .04),
                      border: Border.all(
                          color: Colors.white.withValues(alpha: .08)),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(_runNote ??
                        "No forecast rows returned. Adjust scope or days, then try again."),
                  ),
                ),

              const SizedBox(height: 12),

              // ===== Top chart =====
              _sectionLabel(
                context,
                    () {
                  switch (_sort) {
                    case SortMode.mph:
                      return _windMetric == WindMetric.gust
                          ? "Top by gust mph"
                          : "Top by sustained mph";
                    case SortMode.threat:
                      return "Top by threat level";
                    case SortMode.customers:
                      return "Top by predicted customers out";
                  }
                }(),
              ),
              _BarPreviewCard(
                items: sorted.take(6).map((r) {
                  if (_sort == SortMode.mph) {
                    final v = _windMetric == WindMetric.gust
                        ? (r.maxGust ?? 0).round()
                        : (r.maxSustained ?? 0).round();
                    return {"name": "${r.county} (${r.state})", "value": v};
                  } else if (_sort == SortMode.threat) {
                    return {
                      "name": "${r.county} (${r.state})",
                      "value": r.threatLevel
                    };
                  } else {
                    return {
                      "name": "${r.county} (${r.state})",
                      "value": r.predictedCustomersOut
                    };
                  }
                }).toList(),
              ),

              const SizedBox(height: 16),

              SizedBox(
                width: double.infinity,
                child: DAButton(
                  label: "Run Forecast",
                  icon: Icons.analytics,
                  onPressed: _loading ? null : () => _run(),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // ===================== UI helpers =====================
  Widget _sectionLabel(BuildContext context, String text) => Align(
    alignment: Alignment.centerLeft,
    child: Text(text, style: Theme.of(context).textTheme.labelLarge),
  );

  Widget _cardsRow(
      BuildContext context, {
        required String threat,
        required Color threatColor,
        required String staging,
        required String scopeLabel,
        required String maxGust,
        required String maxSustained,
      }) {
    final cards = <Widget>[
      _InfoCard(
          title: "Threat",
          body: threat,
          accent: threatColor,
          subtitle: "Wind outage risk"),
      _InfoCard(
          title: "Max gust",
          body: "$maxGust mph",
          accent: brandOrange,
          subtitle: "Peak in selection"),
      _InfoCard(
          title: "Max sustained",
          body: "$maxSustained mph",
          accent: const Color(0xFF00E5FF),
          subtitle: "Peak in selection"),
      _InfoCard(
          title: "Staging",
          body: scopeLabel,
          accent: const Color(0xFF80CBC4),
          subtitle: staging),
    ];

    return LayoutBuilder(builder: (ctx, c) {
      if (c.maxWidth < 700) {
        return Column(
          children: cards
              .map((w) =>
              Padding(padding: const EdgeInsets.only(bottom: 12), child: w))
              .toList(),
        );
      } else {
        return Wrap(
          spacing: 12,
          runSpacing: 12,
          children: cards
              .map((w) => SizedBox(width: (c.maxWidth - 24) / 3, child: w))
              .toList(),
        );
      }
    });
  }
}

// ===================== Small widgets =====================
class _TBtn extends StatelessWidget {
  const _TBtn(this.text);
  final String text;
  @override
  Widget build(BuildContext context) => Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      child: Text(text));
}

class _InfoCard extends StatelessWidget {
  const _InfoCard(
      {required this.title,
        required this.body,
        required this.accent,
        required this.subtitle});
  final String title;
  final String body;
  final Color accent;
  final String subtitle;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .04),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white.withValues(alpha: .08)),
        boxShadow: const [
          BoxShadow(
              blurRadius: 22,
              spreadRadius: -6,
              offset: Offset(0, 10),
              color: Colors.black54)
        ],
      ),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Text(title,
            style: const TextStyle(fontSize: 12, color: Colors.white70)),
        const SizedBox(height: 6),
        Row(children: [
          Container(
              width: 10,
              height: 10,
              decoration: BoxDecoration(color: accent, shape: BoxShape.circle)),
          const SizedBox(width: 8),
          Text(body,
              style:
              const TextStyle(fontSize: 18, fontWeight: FontWeight.w800)),
        ]),
        const SizedBox(height: 6),
        Text(subtitle,
            style: const TextStyle(fontSize: 12, color: Colors.white60)),
      ]),
    );
  }
}

class _BarPreviewCard extends StatelessWidget {
  const _BarPreviewCard({required this.items});
  final List<Map<String, dynamic>> items;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Colors.white.withValues(alpha: .04),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white.withValues(alpha: .08)),
      ),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Row(children: const [
          Icon(Icons.bar_chart, size: 16),
          SizedBox(width: 6),
          Text("Top view", style: TextStyle(fontWeight: FontWeight.w700))
        ]),
        const SizedBox(height: 10),
        SizedBox(
            height: 140, child: CustomPaint(painter: _MiniBarPainter(items))),
      ]),
    );
  }
}

class _MiniBarPainter extends CustomPainter {
  _MiniBarPainter(this.items);
  final List<Map<String, dynamic>> items;

  @override
  void paint(Canvas canvas, Size size) {
    final bars = items.take(6).toList();
    if (bars.isEmpty) return;

    final maxVal = bars
        .map((e) => (e["value"] as num).toDouble())
        .reduce((a, b) => a > b ? a : b);
    final barW = size.width / (bars.length * 1.6);
    final paint = Paint()..isAntiAlias = true;
    final textPainter = TextPainter(textDirection: TextDirection.ltr);

    for (int i = 0; i < bars.length; i++) {
      final x = (i * 1.6 + .3) * barW;
      final v = (bars[i]["value"] as num).toDouble();
      final h = maxVal == 0 ? 0 : v / maxVal * (size.height - 28);
      final r = RRect.fromRectAndRadius(
        Rect.fromLTWH(x, size.height - h - 18, barW.toDouble(), h.toDouble()),
        const Radius.circular(6),
      );
      final shader =
      const LinearGradient(colors: [Color(0xFFFFB15A), Color(0xFFFF6A00)])
          .createShader(r.outerRect);
      paint..shader = shader;
      canvas.drawRRect(r, paint);

      final label = TextSpan(
          text: v.toStringAsFixed(0),
          style: const TextStyle(fontSize: 10, color: Colors.white70));
      textPainter.text = label;
      textPainter.layout(minWidth: 0, maxWidth: barW * 1.5);
      textPainter.paint(canvas, Offset(x - 2, size.height - 16));
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}
