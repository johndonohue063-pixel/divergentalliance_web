import 'package:flutter/material.dart';
import '../ui/da_button.dart';
import '../services/wx_client.dart';
import '../screens/weather_center_gate.dart';

class WeatherCenter extends StatefulWidget {
  static const route = '/weather-center';
  const WeatherCenter({super.key});
  @override
  State<WeatherCenter> createState() => _WeatherCenterState();
}

class _WeatherCenterState extends State<WeatherCenter> {\n  List<SppRow> _rows = [];\n  bool _loading = false;\n
  // ----- Scope cascade -----
  final Map<String, List<String>> regionStates = {
    'Gulf': ['Texas', 'Louisiana', 'Mississippi', 'Alabama', 'Florida'],
    'Southeast': [
      'Florida',
      'Georgia',
      'South Carolina',
      'North Carolina',
      'Tennessee',
      'Alabama',
      'Mississippi'
    ],
    'East Coast': [
      'Florida',
      'Georgia',
      'South Carolina',
      'North Carolina',
      'Virginia',
      'Maryland',
      'Delaware',
      'New Jersey',
      'New York',
      'Connecticut',
      'Rhode Island',
      'Massachusetts'
    ],
    'Midwest': [
      'Illinois',
      'Indiana',
      'Ohio',
      'Michigan',
      'Wisconsin',
      'Minnesota',
      'Missouri',
      'Iowa'
    ],
    'West': [
      'California',
      'Oregon',
      'Washington',
      'Nevada',
      'Arizona',
      'Utah',
      'Colorado',
      'New Mexico'
    ],
  };

  String region = 'Nationwide';
  String? stateSel;

  // ----- Forecast controls -----
  int daysOut = 0; // 0..10
  double probability = 35; // wind outage probability %
  bool crewsEstimate = true;

  @override
  void initState() {
    super.initState();
    // Hard guard: require PIN once per app session.
    if (WeatherCenterGate.authorized != true) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        Navigator.pushReplacementNamed(context, WeatherCenterGate.route);
      });
    }
  }

  List<String> currentStates() =>
      region == 'Nationwide' ? const [] : (regionStates[region] ?? const []);

  // ----- Threat logic (wind-first) -----
  int threatLevel(double p) {
    if (p >= 45) return 3;
    if (p >= 30) return 2;
    if (p >= 20) return 1;
    return 0;
  }

  String threatLabel(int lvl) => switch (lvl) {
        3 => 'Level 3',
        2 => 'Level 2',
        1 => 'Level 1',
        _ => 'Level 0'
      };
  Color threatColor(int lvl) => switch (lvl) {
        3 => const Color(0xFFB00020), // crimson
        2 => const Color(0xFFFF6A00), // DA orange
        1 => const Color(0xFFFFC107), // amber
        _ => const Color(0xFF64B5F6), // calm blue
      };

  // ----- Crew estimator (wind, scope-tuned) -----
  // State:  L1=10, L2=30, L3=60
  // Region: L1=50, L2=150, L3=300
  // Nation: L1=100, L2=300, L3=600
  int estimateCrews(double p) {
    final lvl = threatLevel(p);
    String scope = 'Nationwide';
    if (region != 'Nationwide') scope = 'Region';
    if (stateSel != null) scope = 'State';
    final base = switch (scope) {
      'State' => [0, 10, 30, 60],
      'Region' => [0, 50, 150, 300],
      _ => [0, 100, 300, 600],
    };
    return base[lvl];
  }

  // ----- Synthetic â€œTop Countiesâ€ preview for bar mini-chart (UI demo without backend) -----
  List<Map<String, dynamic>> topCountiesPreview() {
  // If we haven't fetched yet, show empty; chart will render after run.
  return _rows.isEmpty
    ? const []
    : _rows
        .toList()
        ..sort((a,b)=>b.predictedCustomersOut.compareTo(a.predictedCustomersOut))
        ..removeRange(6, (_rows.length<6?_rows.length:6)); // top 6
}
  String stagingSuggestion() {
    if (stateSel != null) {
      return 'Stage near:  logistics hub â€¢ position 1 crew base west, 1 east.';
    }
    if (region != 'Nationwide') {
      return 'Stage on  perimeter â€¢ pre-position scout crews along major corridors.';
    }
    return 'Nationwide posture â€¢ hold rapid-deploy strike teams at Tier-1 airports.';
  }

  Future<void> _run() async {
  // Guard: require PIN
  if (WeatherCenterGate.authorized != true) {
    Navigator.pushReplacementNamed(context, WeatherCenterGate.route);
    return;
  }

  setState(() => _loading = true);

  try {
    // Build params; daysOut already in state
    final scopeRegion = region == 'Nationwide' ? null : region;
    final scopeState  = stateSel;

    // Expectation: WxClient.nationalCsv returns List<Map<String,dynamic>> with SPP columns
    final List<Map<String,dynamic>> data = await WxClient.nationalCsv(
      region: scopeRegion,
      state: scopeState,
      daysOut: daysOut,
    );

    final rows = data.map((e) => SppRow.fromJson(e)).toList();

    // Derive overall badge from backend truth: max threat level and top crews
    rows.sort((a,b)=>b.predictedCustomersOut.compareTo(a.predictedCustomersOut));
    final lvl = rows.isEmpty ? 0 : rows.map((e)=>e.threatLevel).fold<int>(0, (m,v)=>v>m?v:m);
    final crews = rows.isEmpty ? 0 : rows.take(10).fold<int>(0, (s,r)=>s + r.suggestedCrews);

    setState(() {
      _rows = rows;
      // Drive the UI with backend outputs
      probability = rows.isEmpty ? probability : rows.first.prob; // keep slider aligned to lead row
      // For cards
      _derivedThreat = lvl;
      _derivedCrews = crews;
      _derivedStaging = rows.isNotEmpty ? rows.first.staging : stagingSuggestion();
    });
  } catch (e) {
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Forecast fetch failed: ' + e.toString())));
    }
  } finally {
    if (mounted) setState(() => _loading = false);
  }
}  @override
  Widget build(BuildContext context) {
    final lvl = _rows.isEmpty ? threatLevel(probability) : _derivedThreat;
    final states = currentStates();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Weather Center'),
        actions: [
          Container(
            margin: const EdgeInsets.symmetric(vertical: 10, horizontal: 12),
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
            decoration: BoxDecoration(
              color: threatColor(lvl).withOpacity(.18),
              border: Border.all(color: threatColor(lvl), width: 1),
              borderRadius: BorderRadius.circular(20),
            ),
            child: Row(children: [
              const Icon(Icons.bolt_rounded, size: 16),
              const SizedBox(width: 6),
              Text(threatLabel(lvl),
                  style: const TextStyle(fontWeight: FontWeight.w700)),
            ]),
          )
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          children: [
            // ---- Scope row ----
            Row(children: [
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: region,
                  decoration:
                      const InputDecoration(labelText: 'Scope / Region'),
                  items: [
                    const DropdownMenuItem(
                        value: 'Nationwide', child: Text('Nationwide')),
                    ...regionStates.keys
                        .map((r) => DropdownMenuItem(value: r, child: Text(r))),
                  ],
                  onChanged: (v) => setState(() {
                    region = v ?? 'Nationwide';
                    stateSel = null;
                  }),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: DropdownButtonFormField<String>(
                  value: stateSel,
                  decoration: const InputDecoration(labelText: 'State'),
                  items: states
                      .map((s) => DropdownMenuItem(value: s, child: Text(s)))
                      .toList(),
                  onChanged: states.isEmpty
                      ? null
                      : (v) => setState(() => stateSel = v),
                  disabledHint: const Text('â€”'),
                ),
              ),
            ]),

            const SizedBox(height: 12),

            // ---- Days out slider ----
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text('Days out'),
                      Slider(
                        min: 0,
                        max: 10,
                        divisions: 10,
                        value: daysOut.toDouble(),
                        label: daysOut.toString(),
                        onChanged: (v) => setState(() => daysOut = v.round()),
                      ),
                    ],
                  ),
                ),
                SizedBox(
                  width: 64,
                  child: Text('d',
                      textAlign: TextAlign.end,
                      style: const TextStyle(fontWeight: FontWeight.w600)),
                ),
              ],
            ),

            const SizedBox(height: 12),

            // ---- Glass cards row: Threat, Crews, Staging ----
            LayoutBuilder(builder: (ctx, c) {
              final isNarrow = c.maxWidth < 540;
              final cards = <Widget>[
                _InfoCard(
                  title: 'Threat',
                  body: threatLabel(lvl),
                  accent: threatColor(lvl),
                  subtitle: 'Wind outage risk',
                ),
                _InfoCard(
                  title: 'Suggested Crews',
                  body: crewsEstimate ? '' : 'â€”',
                  accent: const Color(0xFFFF6A00),
                  subtitle: crewsEstimate
                      ? 'Based on scope & %'
                      : 'Turn on estimator',
                ),
                _InfoCard(
                  title: 'Staging',
                  body: stateSel ?? region,
                  accent: Colors.tealAccent.shade700,
                  subtitle: _rows.isEmpty ? stagingSuggestion() : _derivedStaging,
                ),
              ];
              if (isNarrow) {
                return Column(
                    children: cards
                        .map((w) => Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: w))
                        .toList());
              } else {
                return Row(
                    children: cards
                        .map((w) => Expanded(
                            child: Padding(
                                padding: const EdgeInsets.only(right: 12),
                                child: w)))
                        .toList())
                  ..children.last = Expanded(
                      child:
                          Padding(padding: EdgeInsets.zero, child: cards.last));
              }
            }),

            const SizedBox(height: 12),

            // ---- Wind probability + toggle ----
            Align(
                alignment: Alignment.centerLeft,
                child: Text('Wind Outage Probability: %')),
            Slider(
                min: 0,
                max: 100,
                divisions: 100,
                value: probability,
                onChanged: (v) => setState(() => probability = v)),

            CheckboxListTile(
              value: crewsEstimate,
              onChanged: (v) =>
                  setState(() => crewsEstimate = v ?? crewsEstimate),
              title: const Text('Estimate Crews (wind)'),
              controlAffinity: ListTileControlAffinity.leading,
              contentPadding: EdgeInsets.zero,
            ),

            const SizedBox(height: 6),

            // ---- Mini bar preview card ----
            _BarPreviewCard(items: _rows.take(6).map((r)=>{'name':'\ (\)','out':r.predictedCustomersOut}).toList()),

            const SizedBox(height: 16),

            SizedBox(
              width: double.infinity,
              child: DAButton(
                  label: 'Run Forecast',
                  icon: Icons.analytics,
                  onPressed: _run),
            ),
          ],
        ),
      ),
    );
  }
}

// ===== Support widgets =====

class _InfoCard extends StatelessWidget {
  const _InfoCard(
      {required this.title,
      required this.body,
      required this.accent,
      required this.subtitle});
  final String title;
  final String body;
  final Color accent;
  final String subtitle;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(.04),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white.withOpacity(.08)),
        boxShadow: const [
          BoxShadow(
              blurRadius: 22,
              spreadRadius: -6,
              offset: Offset(0, 10),
              color: Colors.black54)
        ],
      ),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Text(title,
            style: const TextStyle(fontSize: 12, color: Colors.white70)),
        const SizedBox(height: 6),
        Row(children: [
          Container(
              width: 10,
              height: 10,
              decoration: BoxDecoration(color: accent, shape: BoxShape.circle)),
          const SizedBox(width: 8),
          Text(body,
              style:
                  const TextStyle(fontSize: 18, fontWeight: FontWeight.w800)),
        ]),
        const SizedBox(height: 6),
        Text(subtitle,
            style: const TextStyle(fontSize: 12, color: Colors.white60)),
      ]),
    );
  }
}

class _BarPreviewCard extends StatelessWidget {
  const _BarPreviewCard({required this.items});
  final List<Map<String, dynamic>> items;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(.04),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white.withOpacity(.08)),
      ),
      child: Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
        Row(children: const [
          Icon(Icons.bar_chart, size: 16),
          SizedBox(width: 6),
          Text('Top impact areas (preview)',
              style: TextStyle(fontWeight: FontWeight.w700)),
        ]),
        const SizedBox(height: 10),
        SizedBox(
          height: 140,
          child: CustomPaint(painter: _MiniBarPainter(items)),
        ),
      ]),
    );
  }
}

class _MiniBarPainter extends CustomPainter {
  _MiniBarPainter(this.items);
  final List<Map<String, dynamic>> items;

  @override
  void paint(Canvas canvas, Size size) {
    final bars = items.take(6).toList();
    if (bars.isEmpty) return;
    final maxOut = bars
        .map((e) => e['out'] as int)
        .reduce((a, b) => a > b ? a : b)
        .toDouble();
    final barW = size.width / (bars.length * 1.6);
    final paint = Paint()..isAntiAlias = true;
    final textPainter = TextPainter(textDirection: TextDirection.ltr);

    for (int i = 0; i < bars.length; i++) {
      final x = (i * 1.6 + .3) * barW;
      final h = maxOut == 0
          ? 0
          : (bars[i]['out'] as int) / maxOut * (size.height - 28);
      final r = RRect.fromRectAndRadius(
          Rect.fromLTWH(x, size.height - h - 18, barW, h),
          const Radius.circular(6));
      // DA orange gradient
      final shader =
          const LinearGradient(colors: [Color(0xFFFFB15A), Color(0xFFFF6A00)])
              .createShader(r.outerRect);
      paint..shader = shader;
      canvas.drawRRect(r, paint);
      // label (tiny)
      final label = TextSpan(
          text: '',
          style: const TextStyle(fontSize: 10, color: Colors.white70));
      textPainter.text = label;
      textPainter.layout(minWidth: 0, maxWidth: barW * 1.5);
      textPainter.paint(canvas, Offset(x - 2, size.height - 16));
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

class SppRow {
  final String cluster;
  final String county;
  final String state;
  final double prob;             // Wind Outage Probability %
  final int population;
  final int suggestedCrews;
  final int predictedIncidents;
  final int predictedCustomersOut;
  final String staging;
  final String utilities;
  final String peakDate;
  final int threatLevel;         // 0..3 from backend

  SppRow.fromJson(Map<String,dynamic> j)
    : cluster = (j['Cluster'] ?? '').toString(),
      county  = (j['County'] ?? '').toString(),
      state   = (j['State'] ?? '').toString(),
      prob    = (j['Wind Outage Probability %'] ?? j['prob'] ?? 0).toDouble(),
      population = (j['Population'] ?? 0) is String ? int.tryParse(j['Population']) ?? 0 : (j['Population'] ?? 0),
      suggestedCrews = (j['Suggested Crews'] ?? 0) is String ? int.tryParse(j['Suggested Crews']) ?? 0 : (j['Suggested Crews'] ?? 0),
      predictedIncidents = (j['Predicted Incidents'] ?? 0) is String ? int.tryParse(j['Predicted Incidents']) ?? 0 : (j['Predicted Incidents'] ?? 0),
      predictedCustomersOut = (j['Predicted Customers Out'] ?? 0) is String ? int.tryParse(j['Predicted Customers Out']) ?? 0 : (j['Predicted Customers Out'] ?? 0),
      staging = (j['Staging Suggestions'] ?? '').toString(),
      utilities = (j['Primary + Secondary Utilities'] ?? '').toString(),
      peakDate = (j['Predicted Impact Date (peak)'] ?? '').toString(),
      threatLevel = (j['Threat Level'] ?? j['threat'] ?? 0) is String ? int.tryParse(j['Threat Level'] ?? '0') ?? 0 : (j['Threat Level'] ?? 0);
}