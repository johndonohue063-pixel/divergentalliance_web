import 'dart:async';
import 'dart:convert';
import 'dart:io' show Platform;
import 'package:csv/csv.dart';
import 'package:flutter/foundation.dart' show compute, kIsWeb, debugPrint;
import 'package:http/http.dart' as http;

class WxApi {
  WxApi._();

  static String? _base;

  static void discover({String? overrideBase}) {
    _base = overrideBase ?? _defaultBase();
  }

  static String _defaultBase() {
    if (kIsWeb) return 'http://localhost:8010';
    if (Platform.isAndroid) return 'http://10.0.2.2:8010';
    return 'http://127.0.0.1:8010';
  }

  static String get baseUrl => _base ?? _defaultBase();

  static const _timeout = Duration(seconds: 60);

  static Uri _build(String path, Map<String, String?> qp) {
    return Uri.parse('$baseUrl$path').replace(
      queryParameters: {
        for (final e in qp.entries)
          if (e.value != null) e.key: e.value!,
      },
    );
  }

  static Future<String> _getText(Uri uri) async {
    debugPrint('[WxApi] GET $uri');
    final res = await http.get(uri).timeout(_timeout);
    if (res.statusCode != 200) {
      throw Exception('HTTP ${res.statusCode}: ${res.reasonPhrase}');
    }
    return res.body;
  }

  /// Fetch with retries over param name variants and CSV/JSON detection.
  static Future<List<Map<String, dynamic>>> nationalSmart({
    required String region,
    required int maxZones,
    required int threshold,
    required int horizonHours,
    required int windMph,
    String? state,
  }) async {
    // Common params used by all attempts.
    final common = <String, String>{
      if (region != 'national') 'region': region,
      'max_zones': '$maxZones',
      'threshold': '$threshold',
      'wind_mph': '$windMph',
      if (state != null && state.trim().isNotEmpty) if (state != null && state.isNotEmpty) if (state != null && state.isNotEmpty) if (state != null && state.isNotEmpty) 'state': state,
    };

    // Try multiple keys the backend might expect for the time horizon.
    final horizonVariants = <Map<String, String>>[
      {'timeline': '$horizonHours'},      // our original
      {'horizonHours': '$horizonHours'},  // camelCase
      {'horizon_hours': '$horizonHours'}, // snake_case
      {'hours': '$horizonHours'},         // short
    ];

    // Try both CSV & JSON formats.
    final formats = ['csv', 'json'];

    for (final hv in horizonVariants) {
      for (final fmt in formats) {
        final uri = _build('/report/national', {
          ...common,
          ...hv,
          'format': fmt,
        });

        try {
          final text = await _getText(uri);
          final rows = await _decodeToRows(fmt, text);
          debugPrint('[WxApi] ${rows.length} rows via ${hv.keys.first}=$horizonHours format=$fmt');
          if (rows.isNotEmpty) return rows;
        } on TimeoutException {
          // try next variant
          continue;
        } catch (e) {
          // try next variant
          debugPrint('[WxApi] variant failed (${hv.keys.first}, $fmt): $e');
          continue;
        }
      }
    }

    return const [];
  }

  static Future<List<Map<String, dynamic>>> _decodeToRows(String fmt, String body) async {
    final trimmed = body.trimLeft();

    // If we asked for csv but got JSON (or vice-versa), detect and parse anyway.
    if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
      try {
        final decoded = jsonDecode(body);
        if (decoded is List) {
          return decoded.map<Map<String, dynamic>>((e) => Map<String, dynamic>.from(e as Map)).toList();
        }
        if (decoded is Map && decoded['rows'] is List) {
          return (decoded['rows'] as List).map<Map<String, dynamic>>((e) => Map<String, dynamic>.from(e as Map)).toList();
        }
      } catch (_) {
        // fall through to CSV parse attempt
      }
    }

    // CSV parse on a worker isolate
    return compute(_parseCsvToMaps, body);
  }

  static Uri nationalRequestUri({
    required String region,
    required int maxZones,
    required int threshold,
    required int horizonHours,
    required int windMph,
    String? state,
    String format = 'csv',
  }) {
    // Use the primary variant when building a share link.
    return _build('/report/national', {
      if (region != 'national') 'region': region,
      'max_zones': '$maxZones',
      'threshold': '$threshold',
      'timeline': '$horizonHours',  // primary key
      'wind_mph': '$windMph',
      if (state != null && state.trim().isNotEmpty) if (state != null && state.isNotEmpty) if (state != null && state.isNotEmpty) if (state != null && state.isNotEmpty) 'state': state,
      'format': format,
    });
  }

  static Uri nationalCsvUri({
    required String region,
    required int maxZones,
    required int threshold,
    required int horizonHours,
    required int windMph,
    String? state,
  }) =>
      nationalRequestUri(
        region: region,
        maxZones: maxZones,
        threshold: threshold,
        horizonHours: horizonHours,
        windMph: windMph,
        state: state,
        format: 'csv',
      );
}

/// CSV -> List<Map<String,dynamic>>
List<Map<String, dynamic>> _parseCsvToMaps(String csvText) {
  if (csvText.trim().isEmpty) return const [];
  final rows = const CsvToListConverter(
    eol: '\n',
    shouldParseNumbers: false,
  ).convert(csvText);
  if (rows.isEmpty) return const [];
  final header = rows.first.map((e) => (e ?? '').toString().trim()).toList();
  final out = <Map<String, dynamic>>[];
  for (var i = 1; i < rows.length; i++) {
    final r = rows[i];
    if (r.isEmpty) continue;
    final m = <String, dynamic>{};
    for (var j = 0; j < header.length && j < r.length; j++) {
      m[header[j]] = r[j];
    }
    out.add(m);
  }
  return out;
}






